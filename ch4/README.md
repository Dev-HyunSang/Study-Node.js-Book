# http 모듈로 서버 만들기

- 4.1 요청과 응답 이해하기
- 4.2 REST와 라우팅 사용하기
- 4.3 쿠키와 세션 이해히기
- 4.4 http와 http2
- 4.5 cluster
- 4.6 함께 보면 좋은 자료

## [4.1 요청과 응답 이해하기](./01)
서버는 클라인어트가 있기에 동작합니다. 클라이언트에서 서버로 요청(Request)을 보내고, 서버에서는 요청의 내용을 읽고 처리한 뒤에 클라이언트에 응답(Response)을 보냅니다. 

서버에는 요청을 받는 부분과 응답을 보내는 부분이 있어야 합니다. 요청과 응답은 이벤트 방식이라고 생각하면 됩니다. 클라이언트로부터 요청이 왔을 때 어떤 작업을 수행할지 이벤트 리스너를 미리 등록해두어야 합니다.

```js
const http = require('http');

http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf8'});
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Sever!</p>');
}).listen (3000, () => {
    console.log('3000번 포트에서 서버가 대기 중입니다. http://127.0.0.1:3000');
})
```
createServer 메서드 뒤에 listen 메서드가 붙이고 클라이언트에 공개할 포트 번호와 포트 연결 완료 후 실행될 콜백 함수를 넣게 됩니다.

res 객체에는 res.writeHead와 res.write, res.end 메서드가 있습니다. res.writeHead는 응답에 대한 정보를 기록하는 메서드입니다. 첫 번째 인수로 **성공적인 요청임**을 의미하는 200을, 두 번째 인수로 응답에 대한 정보를 보내는데 콘텐츠의 형식이 HTML임을 알리고 있습니다. 또한 한글 표시를 위해 charset을 UTF-8을 지정하였습니다. 이 정보들이 기록되는 부분을 **헤더(Header)**라고 부릅니다.

res.write 메서드의 첫 번째 인수는 클라이언트로 보낼 데이터입니다. 지금은 HTML 모양의 문자열을 보냈지만 버퍼를 보낼 수도 있습니다. 또한 여러 번 호출해서 데이터를 여러 개 보내도 됩니다. 데이터가 기록되는 부분을 본문(Body)이라고 부릅니다.

res.end는 응답을 종료하는 메서드입니다. 만약 인수가 있다면 그 데이터도 클라인언트로 보내고 응답을 종료합니다. 따라서 위의 예제는 res.write에서 ```<h1>Hello Node!</h1>``` 문자열을, res.end에서 ```<p>Hello Server!</p>``` 문자열을 클라이언트로 보낸 후 응답이 종료된 것이빈다. 브라우저는 응답 내용을 받아서 렌더링합니다.

- [HTTP MIME 타입](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
- [HTTP 상태 코드](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)

## [4.2 REST와 라우팅 사용하기](./02)

- GET: 서버 자원을 가져오고자 할 때 사용합니다. 요청의 본문에 데이터를 넣지 않습니다. 데이터를 서버로 보내야 한다면 퀴리스트링을 사용합니다.
- POST: 서버에 자원을 새로 등록하고자 할 때 사용합니다. 요청의 본문에 새로 등록할 데이터를 넣어 보냅니다.
- PUT: 서버의 자원을 요청에 들어 있는 자원으로 치환하고자 할 때 사용합니다. 요청의 본문에 치환할 데이터를 넣어보냅니다.
- PATCH: 서버 자원의 일부만 수정하고자 할 때 사용합니다. 요청의 본문에 일부 수정할 데이터를 넣어 보냅니다.
- DELETE: 서버의 자원을 삭제하고자 할 때 사용합니다. 요청의 본문에 데이터를 넣지 않습니다.
- OPTIONS: 요청을 하기 전에 통신 옵션을 설명하기 위해 사용합니다.

주소 하나가 요청 메서드를 여러 개 가질 수 있습니다. GET 메서드의 /user 주소로 요청을 보내면 사용자 정보를 가져오는 요청이라는 것을 알 수 있고, POST 메서드의 /user 주소로 요청을 보내면 새로운 사용자를 등록하려 한다는 것을 알 수 있습니다. 만약 위의 메서드로 표현하기 애매한 로그인 같은 동작이 있다면 그냥 POST를 사용하면 됩니다.

이렇게 주소와 메서드만 보고 요청의 내용을 알아볼 수 있따는 것이 장점입니다. GET 메서드 같은 경우에는 브라우저에서 캐싱(기억)할 수도 있으므로 같은 주소로 GET 요청을 할 때 서버에서 가져오는 것이 아니라 캐시에서 가져올 수도 있습니다. 이와 같은 방식으로 캐싱이 되면 성능이 좋아집니다.

## [4.3 쿠키와 세션 이해하기](./03)
- **쿠키명=쿠키값**: 기본적인 쿠키의 값입니다. ```mycookie=test``` 또는 ```name=zerocho```와 같이 설정합니다.
- **Expirse=날짜**: 만료 기한입니다. 이 기한이 지나면 쿠기가 제거됩니다. 기본값은 클라이언트가 종료될 때까지입니다.
- **Max-age=초**: Expires와 비슷하지만 날짜 대신 초를 입력할 수 있습니다. 해당 초가 지나면 쿠키가 제거되빈다. Expires보다 우선합니다.
- **Domain=도메인명**: 쿠키가 전송될 도메인을 특정할 수 있습니다. 기본값은 현제 도메인입니다.
- **Path=URL**: 쿠키가 전송될 URL을 특정할 수 있습니다. 기본값은 '/'이고, 이 경우 모든 URL에서 쿠키를 전송할 수 있습니다.
- **Secure**: HTTPS일 경우에만 쿠키가 전송됩니다.
- **HttpOnly**: 설정 시 자바스크립트에서 쿠키에 접근할 수 없습니다. 쿠키 조작을 방지하기 위해 설정하는 것이 좋습니다.

## [4.4 https와 http2](./04)
createServer 메서드가 인수를 두 개 받습니다. 두 번째 인수는 http 모듈과 같이 서버 로직이고, 첫번째 인수는 인증서에 관련된 옵션 객체입니다.  
인증서를 구입하면 pem이나 crt, 또는 key 확장자를 가진 파일들을 제공합니다. 파일들을 fs.readFileSync 메서드로 읽어서 cert, key, ca 옵션에 알맞게 넣으시면 됩니다. 실제 서버에서는 80포트 대신 443포트를 사용하면 됩니다.

노드의 http2 모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용할 수 있게 합니다. http/2는 요청 및 응답 방식이 기존 http/1.1보다 개선되어 휠씬 효율적으로 요청을 보냅니다. http/2를 사용하면 웹의 속도도 많이 개선됩니다.

- [**HTTP/1.1과 HTTP/2의 차이점**](https://seokbeomkim.github.io/posts/http1-http2/)
- [**HTTP1.1 vs HTTP2.0 차이점 간단히 살펴보기**](https://medium.com/@shlee1353/http1-1-vs-http2-0-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EA%B0%84%EB%8B%A8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-5727b7499b78)